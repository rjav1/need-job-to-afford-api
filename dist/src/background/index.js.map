{"version":3,"file":"index.js","sources":["../../../src/lib/tab-handler.ts","../../../src/background/index.ts"],"sourcesContent":["/**\n * Multi-Tab Handler\n * \n * Manages tab switching, OAuth popup handling, and multi-tab workflows.\n * Detects when job sites open new tabs (LinkedIn auth, external forms)\n * and handles them gracefully.\n */\n\n// ========================================\n// Types\n// ========================================\n\nexport interface TabInfo {\n  id: number;\n  windowId: number;\n  url: string;\n  title: string;\n  active: boolean;\n  status: 'loading' | 'complete';\n  openerTabId?: number;\n  createdAt: number;\n}\n\nexport interface TabSession {\n  id: string;\n  originTab: TabInfo;\n  childTabs: TabInfo[];\n  purpose: TabPurpose;\n  state: TabSessionState;\n  startedAt: number;\n  completedAt?: number;\n  timeout: number;\n  autoClose: boolean;\n}\n\nexport type TabPurpose = \n  | 'oauth'           // OAuth login flow (LinkedIn, Google, etc.)\n  | 'external-form'   // External form (separate ATS page)\n  | 'document-upload' // Document upload/preview\n  | 'verification'    // Email/phone verification\n  | 'unknown';\n\nexport type TabSessionState = \n  | 'active'          // Session in progress\n  | 'waiting'         // Waiting for user action in popup\n  | 'completed'       // Successfully completed\n  | 'failed'          // Failed or timed out\n  | 'cancelled';      // User cancelled\n\nexport interface OAuthProvider {\n  name: string;\n  urlPatterns: RegExp[];\n  successPatterns: RegExp[];\n  failurePatterns: RegExp[];\n  timeout: number;\n}\n\nexport interface TabHandlerConfig {\n  defaultTimeout: number;          // Default timeout for tab sessions (ms)\n  oauthTimeout: number;            // OAuth-specific timeout (ms)\n  pollInterval: number;            // How often to check tab status (ms)\n  autoCloseOnSuccess: boolean;     // Auto-close child tabs on success\n  returnToOrigin: boolean;         // Return to origin tab on completion\n  maxChildTabs: number;            // Max child tabs before warning\n}\n\nexport interface TabEvent {\n  type: TabEventType;\n  session: TabSession;\n  tab?: TabInfo;\n  data?: any;\n}\n\nexport type TabEventType = \n  | 'session-started'\n  | 'tab-opened'\n  | 'tab-closed'\n  | 'tab-navigated'\n  | 'oauth-detected'\n  | 'oauth-success'\n  | 'oauth-failed'\n  | 'session-completed'\n  | 'session-failed'\n  | 'session-timeout';\n\ntype TabEventCallback = (event: TabEvent) => void;\n\n// ========================================\n// OAuth Provider Definitions\n// ========================================\n\nconst OAUTH_PROVIDERS: OAuthProvider[] = [\n  {\n    name: 'LinkedIn',\n    urlPatterns: [\n      /linkedin\\.com\\/oauth/i,\n      /linkedin\\.com\\/uas\\/login/i,\n      /linkedin\\.com\\/checkpoint/i,\n      /linkedin\\.com\\/authwall/i,\n    ],\n    successPatterns: [\n      /linkedin\\.com\\/feed/i,\n      /linkedin\\.com\\/in\\//i,\n      /callback.*code=/i,\n      /\\?oauth_token=/i,\n    ],\n    failurePatterns: [\n      /linkedin\\.com\\/uas\\/login.*error/i,\n      /access_denied/i,\n    ],\n    timeout: 120000, // 2 minutes\n  },\n  {\n    name: 'Google',\n    urlPatterns: [\n      /accounts\\.google\\.com\\/o\\/oauth/i,\n      /accounts\\.google\\.com\\/signin/i,\n      /accounts\\.google\\.com\\/ServiceLogin/i,\n    ],\n    successPatterns: [\n      /callback.*code=/i,\n      /oauth2callback/i,\n      /\\?state=.*&code=/i,\n    ],\n    failurePatterns: [\n      /error=access_denied/i,\n      /error=consent_required/i,\n    ],\n    timeout: 120000,\n  },\n  {\n    name: 'Microsoft',\n    urlPatterns: [\n      /login\\.microsoftonline\\.com/i,\n      /login\\.live\\.com/i,\n      /microsoft\\.com\\/oauth/i,\n    ],\n    successPatterns: [\n      /callback.*code=/i,\n      /\\?code=.*&state=/i,\n    ],\n    failurePatterns: [\n      /error=access_denied/i,\n      /error_description=/i,\n    ],\n    timeout: 120000,\n  },\n  {\n    name: 'GitHub',\n    urlPatterns: [\n      /github\\.com\\/login\\/oauth/i,\n      /github\\.com\\/login\\?/i,\n      /github\\.com\\/sessions/i,\n    ],\n    successPatterns: [\n      /callback.*code=/i,\n      /github\\.com\\/settings/i,\n    ],\n    failurePatterns: [\n      /error=access_denied/i,\n    ],\n    timeout: 120000,\n  },\n  {\n    name: 'Indeed',\n    urlPatterns: [\n      /secure\\.indeed\\.com\\/auth/i,\n      /indeed\\.com\\/account\\/login/i,\n    ],\n    successPatterns: [\n      /indeed\\.com\\/jobs/i,\n      /indeed\\.com\\/viewjob/i,\n    ],\n    failurePatterns: [\n      /login.*error/i,\n    ],\n    timeout: 120000,\n  },\n];\n\n// ATS patterns that may open new tabs\nconst ATS_PATTERNS: { name: string; patterns: RegExp[] }[] = [\n  { name: 'Greenhouse', patterns: [/boards\\.greenhouse\\.io/i, /greenhouse\\.io\\/embed/i] },\n  { name: 'Lever', patterns: [/jobs\\.lever\\.co/i] },\n  { name: 'Workday', patterns: [/myworkdayjobs\\.com/i, /workday\\.com/i] },\n  { name: 'iCIMS', patterns: [/icims\\.com/i, /careers-.*\\.icims\\.com/i] },\n  { name: 'Taleo', patterns: [/taleo\\.net/i] },\n  { name: 'BrassRing', patterns: [/brassring\\.com/i] },\n  { name: 'SmartRecruiters', patterns: [/smartrecruiters\\.com/i, /jobs\\.smartrecruiters\\.com/i] },\n  { name: 'Ashby', patterns: [/jobs\\.ashbyhq\\.com/i, /ashbyhq\\.com/i] },\n];\n\n// ========================================\n// Default Configuration\n// ========================================\n\nconst DEFAULT_CONFIG: TabHandlerConfig = {\n  defaultTimeout: 300000,      // 5 minutes\n  oauthTimeout: 120000,        // 2 minutes\n  pollInterval: 500,           // 500ms\n  autoCloseOnSuccess: true,\n  returnToOrigin: true,\n  maxChildTabs: 5,\n};\n\n// ========================================\n// Tab Handler Class\n// ========================================\n\nexport class TabHandler {\n  private config: TabHandlerConfig;\n  private sessions: Map<string, TabSession> = new Map();\n  private tabToSession: Map<number, string> = new Map();\n  private eventCallbacks: TabEventCallback[] = [];\n  private isListening: boolean = false;\n  private pollIntervals: Map<string, NodeJS.Timeout> = new Map();\n\n  constructor(config: Partial<TabHandlerConfig> = {}) {\n    this.config = { ...DEFAULT_CONFIG, ...config };\n  }\n\n  // ----------------------------------------\n  // Lifecycle\n  // ----------------------------------------\n\n  /**\n   * Start listening for tab events\n   */\n  startListening(): void {\n    if (this.isListening) return;\n    this.isListening = true;\n\n    // Listen for new tabs being created\n    chrome.tabs.onCreated.addListener(this.handleTabCreated);\n    \n    // Listen for tab updates (navigation, load state)\n    chrome.tabs.onUpdated.addListener(this.handleTabUpdated);\n    \n    // Listen for tabs being closed\n    chrome.tabs.onRemoved.addListener(this.handleTabRemoved);\n    \n    // Listen for tab activation\n    chrome.tabs.onActivated.addListener(this.handleTabActivated);\n\n    console.log('[TabHandler] Started listening for tab events');\n  }\n\n  /**\n   * Stop listening for tab events\n   */\n  stopListening(): void {\n    if (!this.isListening) return;\n    this.isListening = false;\n\n    chrome.tabs.onCreated.removeListener(this.handleTabCreated);\n    chrome.tabs.onUpdated.removeListener(this.handleTabUpdated);\n    chrome.tabs.onRemoved.removeListener(this.handleTabRemoved);\n    chrome.tabs.onActivated.removeListener(this.handleTabActivated);\n\n    // Clear all poll intervals\n    this.pollIntervals.forEach(interval => clearInterval(interval));\n    this.pollIntervals.clear();\n\n    console.log('[TabHandler] Stopped listening for tab events');\n  }\n\n  /**\n   * Register event callback\n   */\n  onEvent(callback: TabEventCallback): () => void {\n    this.eventCallbacks.push(callback);\n    return () => {\n      this.eventCallbacks = this.eventCallbacks.filter(cb => cb !== callback);\n    };\n  }\n\n  // ----------------------------------------\n  // Session Management\n  // ----------------------------------------\n\n  /**\n   * Start a new tab session for tracking child tabs\n   * Call this before an action that might open new tabs (e.g., clicking \"Sign in with LinkedIn\")\n   */\n  async startSession(originTabId: number, purpose: TabPurpose = 'unknown'): Promise<TabSession> {\n    const originTab = await this.getTabInfo(originTabId);\n    \n    if (!originTab) {\n      throw new Error(`Origin tab ${originTabId} not found`);\n    }\n\n    const session: TabSession = {\n      id: this.generateSessionId(),\n      originTab,\n      childTabs: [],\n      purpose,\n      state: 'active',\n      startedAt: Date.now(),\n      timeout: purpose === 'oauth' ? this.config.oauthTimeout : this.config.defaultTimeout,\n      autoClose: this.config.autoCloseOnSuccess,\n    };\n\n    this.sessions.set(session.id, session);\n    this.tabToSession.set(originTabId, session.id);\n\n    // Start timeout monitoring\n    this.startSessionTimeout(session);\n\n    this.emitEvent({ type: 'session-started', session });\n\n    console.log(`[TabHandler] Started session ${session.id} for tab ${originTabId} (${purpose})`);\n    return session;\n  }\n\n  /**\n   * Get active session for a tab (either as origin or child)\n   */\n  getSessionForTab(tabId: number): TabSession | undefined {\n    const sessionId = this.tabToSession.get(tabId);\n    if (sessionId) {\n      return this.sessions.get(sessionId);\n    }\n    return undefined;\n  }\n\n  /**\n   * Get all active sessions\n   */\n  getActiveSessions(): TabSession[] {\n    return Array.from(this.sessions.values()).filter(s => s.state === 'active' || s.state === 'waiting');\n  }\n\n  /**\n   * Complete a session (success)\n   */\n  async completeSession(sessionId: string, autoReturn: boolean = true): Promise<void> {\n    const session = this.sessions.get(sessionId);\n    if (!session) return;\n\n    session.state = 'completed';\n    session.completedAt = Date.now();\n\n    // Stop timeout monitoring\n    this.stopSessionTimeout(sessionId);\n\n    // Auto-close child tabs if configured\n    if (session.autoClose) {\n      for (const childTab of session.childTabs) {\n        try {\n          await chrome.tabs.remove(childTab.id);\n          console.log(`[TabHandler] Auto-closed child tab ${childTab.id}`);\n        } catch (e) {\n          // Tab may already be closed\n        }\n      }\n    }\n\n    // Return to origin tab if configured\n    if (autoReturn && this.config.returnToOrigin) {\n      try {\n        await chrome.tabs.update(session.originTab.id, { active: true });\n        await chrome.windows.update(session.originTab.windowId, { focused: true });\n        console.log(`[TabHandler] Returned to origin tab ${session.originTab.id}`);\n      } catch (e) {\n        console.warn(`[TabHandler] Could not return to origin tab:`, e);\n      }\n    }\n\n    this.emitEvent({ type: 'session-completed', session });\n\n    // Clean up session tracking\n    this.cleanupSession(sessionId);\n  }\n\n  /**\n   * Fail a session\n   */\n  failSession(sessionId: string, reason: string): void {\n    const session = this.sessions.get(sessionId);\n    if (!session) return;\n\n    session.state = 'failed';\n    session.completedAt = Date.now();\n\n    this.stopSessionTimeout(sessionId);\n    this.emitEvent({ type: 'session-failed', session, data: { reason } });\n    this.cleanupSession(sessionId);\n\n    console.log(`[TabHandler] Session ${sessionId} failed: ${reason}`);\n  }\n\n  /**\n   * Cancel a session\n   */\n  async cancelSession(sessionId: string): Promise<void> {\n    const session = this.sessions.get(sessionId);\n    if (!session) return;\n\n    session.state = 'cancelled';\n    session.completedAt = Date.now();\n\n    this.stopSessionTimeout(sessionId);\n\n    // Close child tabs\n    for (const childTab of session.childTabs) {\n      try {\n        await chrome.tabs.remove(childTab.id);\n      } catch (e) {\n        // Tab may already be closed\n      }\n    }\n\n    this.cleanupSession(sessionId);\n    console.log(`[TabHandler] Session ${sessionId} cancelled`);\n  }\n\n  // ----------------------------------------\n  // Tab Operations\n  // ----------------------------------------\n\n  /**\n   * Switch to a specific tab\n   */\n  async switchToTab(tabId: number): Promise<void> {\n    try {\n      const tab = await chrome.tabs.get(tabId);\n      await chrome.tabs.update(tabId, { active: true });\n      await chrome.windows.update(tab.windowId, { focused: true });\n    } catch (e) {\n      console.error(`[TabHandler] Failed to switch to tab ${tabId}:`, e);\n      throw e;\n    }\n  }\n\n  /**\n   * Wait for a tab to reach a specific URL pattern\n   */\n  async waitForNavigation(\n    tabId: number, \n    urlPattern: RegExp, \n    timeout: number = 30000\n  ): Promise<TabInfo> {\n    return new Promise((resolve, reject) => {\n      const startTime = Date.now();\n      \n      const checkTab = async () => {\n        try {\n          const tab = await chrome.tabs.get(tabId);\n          \n          if (tab.url && urlPattern.test(tab.url)) {\n            resolve(this.chromeTabToInfo(tab));\n            return true;\n          }\n          \n          if (Date.now() - startTime > timeout) {\n            reject(new Error(`Timeout waiting for navigation to ${urlPattern}`));\n            return true;\n          }\n          \n          return false;\n        } catch (e) {\n          reject(new Error(`Tab ${tabId} was closed`));\n          return true;\n        }\n      };\n\n      const poll = async () => {\n        const done = await checkTab();\n        if (!done) {\n          setTimeout(poll, this.config.pollInterval);\n        }\n      };\n\n      poll();\n    });\n  }\n\n  /**\n   * Wait for a new tab to open from current tab\n   */\n  async waitForNewTab(\n    originTabId: number,\n    timeout: number = 10000\n  ): Promise<TabInfo> {\n    return new Promise((resolve, reject) => {\n      const startTime = Date.now();\n      let resolved = false;\n\n      const listener = (tab: chrome.tabs.Tab) => {\n        if (resolved) return;\n        \n        // Check if this tab was opened from our origin tab\n        if (tab.openerTabId === originTabId) {\n          resolved = true;\n          chrome.tabs.onCreated.removeListener(listener);\n          resolve(this.chromeTabToInfo(tab));\n        }\n      };\n\n      chrome.tabs.onCreated.addListener(listener);\n\n      // Timeout handler\n      setTimeout(() => {\n        if (!resolved) {\n          resolved = true;\n          chrome.tabs.onCreated.removeListener(listener);\n          reject(new Error('Timeout waiting for new tab'));\n        }\n      }, timeout);\n    });\n  }\n\n  /**\n   * Wait for a tab to close\n   */\n  async waitForTabClose(tabId: number, timeout: number = 60000): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const startTime = Date.now();\n      let resolved = false;\n\n      const listener = (closedTabId: number) => {\n        if (closedTabId === tabId && !resolved) {\n          resolved = true;\n          chrome.tabs.onRemoved.removeListener(listener);\n          resolve();\n        }\n      };\n\n      chrome.tabs.onRemoved.addListener(listener);\n\n      // Check if already closed\n      chrome.tabs.get(tabId).catch(() => {\n        if (!resolved) {\n          resolved = true;\n          chrome.tabs.onRemoved.removeListener(listener);\n          resolve();\n        }\n      });\n\n      setTimeout(() => {\n        if (!resolved) {\n          resolved = true;\n          chrome.tabs.onRemoved.removeListener(listener);\n          reject(new Error('Timeout waiting for tab to close'));\n        }\n      }, timeout);\n    });\n  }\n\n  // ----------------------------------------\n  // OAuth Handling\n  // ----------------------------------------\n\n  /**\n   * Handle OAuth flow - waits for OAuth to complete and returns to origin\n   */\n  async handleOAuthFlow(\n    originTabId: number,\n    provider?: string\n  ): Promise<{ success: boolean; error?: string }> {\n    const session = await this.startSession(originTabId, 'oauth');\n\n    try {\n      // Wait for OAuth popup to open\n      const oauthTab = await this.waitForNewTab(originTabId, 10000);\n      \n      console.log(`[TabHandler] OAuth popup opened: ${oauthTab.url}`);\n\n      // Detect provider from URL\n      const detectedProvider = this.detectOAuthProvider(oauthTab.url);\n      if (detectedProvider) {\n        this.emitEvent({ type: 'oauth-detected', session, data: { provider: detectedProvider.name } });\n      }\n\n      // Wait for OAuth to complete (success or failure)\n      const result = await this.waitForOAuthCompletion(oauthTab.id, detectedProvider);\n      \n      if (result.success) {\n        this.emitEvent({ type: 'oauth-success', session, data: { provider: detectedProvider?.name } });\n        await this.completeSession(session.id);\n        return { success: true };\n      } else {\n        this.emitEvent({ type: 'oauth-failed', session, data: { error: result.error } });\n        this.failSession(session.id, result.error || 'OAuth failed');\n        return { success: false, error: result.error };\n      }\n\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : 'OAuth flow failed';\n      this.failSession(session.id, errorMsg);\n      return { success: false, error: errorMsg };\n    }\n  }\n\n  /**\n   * Detect OAuth provider from URL\n   */\n  detectOAuthProvider(url: string): OAuthProvider | undefined {\n    for (const provider of OAUTH_PROVIDERS) {\n      if (provider.urlPatterns.some(pattern => pattern.test(url))) {\n        return provider;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Wait for OAuth to complete\n   */\n  private async waitForOAuthCompletion(\n    tabId: number,\n    provider?: OAuthProvider\n  ): Promise<{ success: boolean; error?: string }> {\n    const timeout = provider?.timeout || this.config.oauthTimeout;\n    const startTime = Date.now();\n\n    return new Promise((resolve) => {\n      let resolved = false;\n\n      const checkCompletion = async () => {\n        if (resolved) return;\n\n        try {\n          const tab = await chrome.tabs.get(tabId);\n          const url = tab.url || '';\n\n          // Check for success\n          if (provider) {\n            if (provider.successPatterns.some(p => p.test(url))) {\n              resolved = true;\n              resolve({ success: true });\n              return;\n            }\n            if (provider.failurePatterns.some(p => p.test(url))) {\n              resolved = true;\n              resolve({ success: false, error: 'OAuth was denied or failed' });\n              return;\n            }\n          }\n\n          // Generic success patterns (callback with code)\n          if (/[?&]code=/.test(url) || /oauth.*callback/i.test(url)) {\n            resolved = true;\n            resolve({ success: true });\n            return;\n          }\n\n          // Generic failure patterns\n          if (/error=access_denied/i.test(url) || /error=consent_required/i.test(url)) {\n            resolved = true;\n            resolve({ success: false, error: 'Access denied' });\n            return;\n          }\n\n          // Timeout check\n          if (Date.now() - startTime > timeout) {\n            resolved = true;\n            resolve({ success: false, error: 'OAuth timeout' });\n            return;\n          }\n\n          // Continue polling\n          setTimeout(checkCompletion, this.config.pollInterval);\n\n        } catch (e) {\n          // Tab was closed - could be success (redirect closed it) or user cancelled\n          resolved = true;\n          resolve({ success: true }); // Assume success if tab closed without error URL\n        }\n      };\n\n      // Also listen for tab close\n      const closeListener = (closedTabId: number) => {\n        if (closedTabId === tabId && !resolved) {\n          resolved = true;\n          chrome.tabs.onRemoved.removeListener(closeListener);\n          resolve({ success: true }); // Tab closed = assume success\n        }\n      };\n      chrome.tabs.onRemoved.addListener(closeListener);\n\n      checkCompletion();\n    });\n  }\n\n  // ----------------------------------------\n  // ATS Detection\n  // ----------------------------------------\n\n  /**\n   * Detect if a URL is an ATS system\n   */\n  detectATS(url: string): { name: string; patterns: RegExp[] } | undefined {\n    for (const ats of ATS_PATTERNS) {\n      if (ats.patterns.some(pattern => pattern.test(url))) {\n        return ats;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Check if current page might open external tabs\n   */\n  mightOpenExternalTabs(url: string): boolean {\n    // ATS systems often open external auth or forms\n    if (this.detectATS(url)) return true;\n    \n    // Job boards\n    const jobBoardPatterns = [\n      /linkedin\\.com\\/jobs/i,\n      /indeed\\.com/i,\n      /glassdoor\\.com/i,\n      /ziprecruiter\\.com/i,\n      /monster\\.com/i,\n    ];\n    \n    return jobBoardPatterns.some(p => p.test(url));\n  }\n\n  // ----------------------------------------\n  // Tab Event Handlers\n  // ----------------------------------------\n\n  private handleTabCreated = async (tab: chrome.tabs.Tab) => {\n    if (!tab.id) return;\n\n    // Check if this tab was opened from a tracked origin tab\n    if (tab.openerTabId) {\n      const session = this.getSessionForTab(tab.openerTabId);\n      \n      if (session && session.state === 'active') {\n        const tabInfo = this.chromeTabToInfo(tab);\n        session.childTabs.push(tabInfo);\n        this.tabToSession.set(tab.id, session.id);\n\n        // Check for OAuth\n        if (tab.pendingUrl || tab.url) {\n          const url = tab.pendingUrl || tab.url || '';\n          const provider = this.detectOAuthProvider(url);\n          if (provider) {\n            session.purpose = 'oauth';\n            this.emitEvent({ type: 'oauth-detected', session, tab: tabInfo, data: { provider: provider.name } });\n          }\n        }\n\n        this.emitEvent({ type: 'tab-opened', session, tab: tabInfo });\n\n        // Warn if too many child tabs\n        if (session.childTabs.length >= this.config.maxChildTabs) {\n          console.warn(`[TabHandler] Session ${session.id} has ${session.childTabs.length} child tabs!`);\n        }\n\n        console.log(`[TabHandler] Child tab ${tab.id} added to session ${session.id}`);\n      }\n    }\n  };\n\n  private handleTabUpdated = async (\n    tabId: number,\n    changeInfo: chrome.tabs.TabChangeInfo,\n    tab: chrome.tabs.Tab\n  ) => {\n    const session = this.getSessionForTab(tabId);\n    if (!session) return;\n\n    // Update tab info in session\n    const isOrigin = session.originTab.id === tabId;\n    const tabInfo = this.chromeTabToInfo(tab);\n\n    if (isOrigin) {\n      session.originTab = tabInfo;\n    } else {\n      const idx = session.childTabs.findIndex(t => t.id === tabId);\n      if (idx >= 0) {\n        session.childTabs[idx] = tabInfo;\n      }\n    }\n\n    // Check for navigation changes\n    if (changeInfo.url) {\n      this.emitEvent({ type: 'tab-navigated', session, tab: tabInfo });\n\n      // Check for OAuth completion\n      if (session.purpose === 'oauth' && !isOrigin) {\n        const provider = this.detectOAuthProvider(tabInfo.url);\n        if (provider) {\n          const isSuccess = provider.successPatterns.some(p => p.test(tabInfo.url));\n          const isFailure = provider.failurePatterns.some(p => p.test(tabInfo.url));\n\n          if (isSuccess) {\n            this.emitEvent({ type: 'oauth-success', session, tab: tabInfo });\n            await this.completeSession(session.id);\n          } else if (isFailure) {\n            this.emitEvent({ type: 'oauth-failed', session, tab: tabInfo });\n            this.failSession(session.id, 'OAuth access denied');\n          }\n        }\n      }\n    }\n  };\n\n  private handleTabRemoved = (tabId: number) => {\n    const session = this.getSessionForTab(tabId);\n    if (!session) return;\n\n    if (session.originTab.id === tabId) {\n      // Origin tab closed - fail the session\n      this.failSession(session.id, 'Origin tab was closed');\n    } else {\n      // Child tab closed\n      session.childTabs = session.childTabs.filter(t => t.id !== tabId);\n      this.tabToSession.delete(tabId);\n      \n      this.emitEvent({ type: 'tab-closed', session, tab: { id: tabId } as TabInfo });\n\n      // If all child tabs closed and this was an OAuth session, consider it complete\n      if (session.purpose === 'oauth' && session.childTabs.length === 0) {\n        this.completeSession(session.id);\n      }\n    }\n  };\n\n  private handleTabActivated = async (activeInfo: chrome.tabs.TabActiveInfo) => {\n    const session = this.getSessionForTab(activeInfo.tabId);\n    if (session) {\n      // Update which tab is active\n      session.originTab.active = session.originTab.id === activeInfo.tabId;\n      session.childTabs.forEach(t => {\n        t.active = t.id === activeInfo.tabId;\n      });\n    }\n  };\n\n  // ----------------------------------------\n  // Helpers\n  // ----------------------------------------\n\n  private async getTabInfo(tabId: number): Promise<TabInfo | null> {\n    try {\n      const tab = await chrome.tabs.get(tabId);\n      return this.chromeTabToInfo(tab);\n    } catch {\n      return null;\n    }\n  }\n\n  private chromeTabToInfo(tab: chrome.tabs.Tab): TabInfo {\n    return {\n      id: tab.id!,\n      windowId: tab.windowId,\n      url: tab.url || tab.pendingUrl || '',\n      title: tab.title || '',\n      active: tab.active,\n      status: tab.status as 'loading' | 'complete',\n      openerTabId: tab.openerTabId,\n      createdAt: Date.now(),\n    };\n  }\n\n  private generateSessionId(): string {\n    return `tab-session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private startSessionTimeout(session: TabSession): void {\n    const interval = setInterval(() => {\n      if (Date.now() - session.startedAt > session.timeout) {\n        this.emitEvent({ type: 'session-timeout', session });\n        this.failSession(session.id, 'Session timed out');\n      }\n    }, 5000);\n    \n    this.pollIntervals.set(session.id, interval);\n  }\n\n  private stopSessionTimeout(sessionId: string): void {\n    const interval = this.pollIntervals.get(sessionId);\n    if (interval) {\n      clearInterval(interval);\n      this.pollIntervals.delete(sessionId);\n    }\n  }\n\n  private cleanupSession(sessionId: string): void {\n    const session = this.sessions.get(sessionId);\n    if (!session) return;\n\n    // Remove tab-to-session mappings\n    this.tabToSession.delete(session.originTab.id);\n    session.childTabs.forEach(t => this.tabToSession.delete(t.id));\n\n    // Keep session for history but mark completed\n    // Sessions are kept for 5 minutes then cleaned\n    setTimeout(() => {\n      this.sessions.delete(sessionId);\n    }, 300000);\n  }\n\n  private emitEvent(event: TabEvent): void {\n    this.eventCallbacks.forEach(cb => {\n      try {\n        cb(event);\n      } catch (e) {\n        console.error('[TabHandler] Event callback error:', e);\n      }\n    });\n  }\n}\n\n// ========================================\n// Singleton Instance\n// ========================================\n\nlet tabHandlerInstance: TabHandler | null = null;\n\n/**\n * Get the singleton TabHandler instance\n */\nexport function getTabHandler(config?: Partial<TabHandlerConfig>): TabHandler {\n  if (!tabHandlerInstance) {\n    tabHandlerInstance = new TabHandler(config);\n  }\n  return tabHandlerInstance;\n}\n\n/**\n * Initialize and start the tab handler\n */\nexport function initTabHandler(config?: Partial<TabHandlerConfig>): TabHandler {\n  const handler = getTabHandler(config);\n  handler.startListening();\n  return handler;\n}\n\n// ========================================\n// Content Script Utilities\n// ========================================\n\n/**\n * Request the background script to start a tab session\n * (Use from content scripts)\n */\nexport async function requestTabSession(purpose: TabPurpose = 'oauth'): Promise<string> {\n  return new Promise((resolve, reject) => {\n    chrome.runtime.sendMessage(\n      { type: 'TAB_SESSION_START', purpose },\n      (response) => {\n        if (response?.sessionId) {\n          resolve(response.sessionId);\n        } else {\n          reject(new Error(response?.error || 'Failed to start tab session'));\n        }\n      }\n    );\n  });\n}\n\n/**\n * Notify background that we're about to trigger an action that may open a new tab\n */\nexport async function notifyPendingTabOpen(reason: string = 'oauth'): Promise<void> {\n  chrome.runtime.sendMessage({\n    type: 'TAB_PENDING_OPEN',\n    reason,\n    tabId: undefined, // Will be filled by background\n  });\n}\n\n/**\n * Check if we're currently in an OAuth popup\n */\nexport function isOAuthPopup(): boolean {\n  const url = window.location.href;\n  return OAUTH_PROVIDERS.some(p => p.urlPatterns.some(pattern => pattern.test(url)));\n}\n\n/**\n * Check if we returned from an OAuth flow\n */\nexport function isOAuthCallback(): boolean {\n  const url = window.location.href;\n  return /[?&]code=/.test(url) || /oauth.*callback/i.test(url);\n}\n\n// ========================================\n// Background Script Message Handlers\n// ========================================\n\n/**\n * Setup message handlers for tab operations (call from background script)\n */\nexport function setupTabHandlerMessages(): void {\n  const handler = getTabHandler();\n  \n  chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    switch (message.type) {\n      case 'TAB_SESSION_START': {\n        const tabId = sender.tab?.id;\n        if (!tabId) {\n          sendResponse({ error: 'No tab ID' });\n          return false;\n        }\n        \n        handler.startSession(tabId, message.purpose)\n          .then(session => sendResponse({ sessionId: session.id }))\n          .catch(err => sendResponse({ error: err.message }));\n        return true; // async\n      }\n      \n      case 'TAB_SESSION_COMPLETE': {\n        handler.completeSession(message.sessionId);\n        sendResponse({ success: true });\n        return false;\n      }\n      \n      case 'TAB_SESSION_FAIL': {\n        handler.failSession(message.sessionId, message.reason);\n        sendResponse({ success: true });\n        return false;\n      }\n      \n      case 'TAB_PENDING_OPEN': {\n        const tabId = sender.tab?.id;\n        if (tabId) {\n          // Start session automatically if not already tracking\n          const existingSession = handler.getSessionForTab(tabId);\n          if (!existingSession) {\n            handler.startSession(tabId, message.reason || 'unknown');\n          }\n        }\n        sendResponse({ success: true });\n        return false;\n      }\n      \n      case 'TAB_GET_SESSION': {\n        const tabId = sender.tab?.id || message.tabId;\n        if (tabId) {\n          const session = handler.getSessionForTab(tabId);\n          sendResponse({ session: session || null });\n        } else {\n          sendResponse({ session: null });\n        }\n        return false;\n      }\n      \n      case 'TAB_HANDLE_OAUTH': {\n        const tabId = sender.tab?.id;\n        if (!tabId) {\n          sendResponse({ error: 'No tab ID' });\n          return false;\n        }\n        \n        handler.handleOAuthFlow(tabId, message.provider)\n          .then(result => sendResponse(result))\n          .catch(err => sendResponse({ success: false, error: err.message }));\n        return true; // async\n      }\n    }\n    \n    return false;\n  });\n\n  console.log('[TabHandler] Message handlers registered');\n}\n\nexport default TabHandler;\n","// Background service worker for AI Job Applier\n\nimport { initTabHandler, setupTabHandlerMessages } from '../lib/tab-handler';\n\n// Initialize tab handler for multi-tab management (OAuth, external forms)\nconst tabHandler = initTabHandler({\n  autoCloseOnSuccess: true,\n  returnToOrigin: true,\n  oauthTimeout: 120000,\n});\n\n// Setup message handlers for tab operations\nsetupTabHandlerMessages();\n\n// Log tab events for debugging\ntabHandler.onEvent((event) => {\n  console.log(`[TabHandler Event] ${event.type}`, event.session?.id, event.data);\n});\n\n// Handle extension installation\nchrome.runtime.onInstalled.addListener((details) => {\n  if (details.reason === 'install') {\n    // Open options page on first install\n    chrome.runtime.openOptionsPage();\n  }\n});\n\n// Handle messages from content scripts\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n  switch (message.type) {\n    case 'OPEN_OPTIONS':\n      chrome.runtime.openOptionsPage();\n      break;\n      \n    case 'LOG_APPLICATION':\n      // Log application to storage\n      logApplication(message.data);\n      break;\n      \n    case 'GET_PROFILE':\n      // Get profile from storage\n      chrome.storage.local.get('userProfile', (result) => {\n        sendResponse(result.userProfile || null);\n      });\n      return true; // async response\n      \n    case 'NAVIGATE_TO_JOB':\n      // Open job URL in new tab\n      chrome.tabs.create({ url: message.url, active: true }, (tab) => {\n        sendResponse({ tabId: tab?.id });\n      });\n      return true;\n      \n    case 'APPLY_TO_JOB':\n      // Open job in new tab and apply\n      handleApplyToJob(message.job, message.config).then(result => {\n        sendResponse({ result });\n      });\n      return true;\n      \n    case 'GET_APPLY_CONFIG':\n      // Get apply configuration\n      chrome.storage.local.get('applyConfig', (result) => {\n        sendResponse(result.applyConfig || null);\n      });\n      return true;\n      \n    case 'SAVE_APPLY_CONFIG':\n      // Save apply configuration\n      chrome.storage.local.set({ applyConfig: message.config }, () => {\n        sendResponse({ success: true });\n      });\n      return true;\n  }\n});\n\n// Handle apply to job request (swarm mode)\nasync function handleApplyToJob(\n  job: { url: string; title: string; company: string },\n  config: any\n): Promise<any> {\n  return new Promise((resolve) => {\n    // Create new tab for the job\n    chrome.tabs.create({ url: job.url, active: false }, async (tab) => {\n      if (!tab?.id) {\n        resolve({ success: false, error: 'Failed to create tab' });\n        return;\n      }\n      \n      // Wait for page to load\n      const tabId = tab.id;\n      \n      const onCompleted = (details: chrome.webNavigation.WebNavigationFramedCallbackDetails) => {\n        if (details.tabId === tabId && details.frameId === 0) {\n          chrome.webNavigation.onCompleted.removeListener(onCompleted);\n          \n          // Send fill message to content script\n          setTimeout(() => {\n            chrome.tabs.sendMessage(tabId, { \n              type: 'AUTO_APPLY',\n              config,\n            }, (response) => {\n              // Close tab after applying (unless stopped at review)\n              if (response?.result && !response.result.stoppedAtReview) {\n                setTimeout(() => {\n                  chrome.tabs.remove(tabId);\n                }, 2000);\n              }\n              resolve(response?.result || { success: false, error: 'No response from content script' });\n            });\n          }, 2000); // Wait 2s for page to fully render\n        }\n      };\n      \n      chrome.webNavigation.onCompleted.addListener(onCompleted);\n      \n      // Timeout after 30 seconds\n      setTimeout(() => {\n        chrome.webNavigation.onCompleted.removeListener(onCompleted);\n        resolve({ success: false, error: 'Page load timeout' });\n      }, 30000);\n    });\n  });\n}\n\n// Log application to history\nasync function logApplication(data: {\n  companyName: string;\n  jobTitle: string;\n  jobUrl: string;\n}) {\n  const result = await chrome.storage.local.get('applications');\n  const applications = result.applications || [];\n  \n  applications.unshift({\n    id: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n    ...data,\n    appliedAt: new Date().toISOString(),\n    status: 'applied',\n    aiResponsesUsed: [],\n  });\n  \n  // Keep only last 100 applications\n  if (applications.length > 100) {\n    applications.length = 100;\n  }\n  \n  await chrome.storage.local.set({ applications });\n}\n\n// Set up context menu\nchrome.runtime.onInstalled.addListener(() => {\n  chrome.contextMenus.create({\n    id: 'ai-job-applier-fill',\n    title: 'Fill with AI Job Applier',\n    contexts: ['editable'],\n  });\n});\n\n// Handle context menu clicks\nchrome.contextMenus.onClicked.addListener((info, tab) => {\n  if (info.menuItemId === 'ai-job-applier-fill' && tab?.id) {\n    chrome.tabs.sendMessage(tab.id, { type: 'FILL_FIELD_AT_CURSOR' });\n  }\n});\n\nconsole.log('AI Job Applier background script loaded');\n"],"names":[],"mappings":"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"}